#1111111111111
data<-read.table("/Users/dijin/Desktop/ç»Ÿè®¡/minipro/5/bodytemp-heartrate.csv",header = T,sep=",")
male<-data[which(data[,2] == 1),c(1,3)]  #get male
female<-data[which(data[,2] == 2),c(1,3)]  #get female


boxplot(male[,1],female[,1],ylab='temperature',names=c("male","female"),range=1.5)#boxplot
#to see if data come from normal distribution to use t test
qqplot(data[,1],data[,3])
qqnorm(data[,3])   
qqnorm(data[,1])
t.test(male[,1],female[,1], alternative = "two.sided", conf.level = 0.95, var.equal = FALSE) #assume normal and get CI

boxplot(male[,2],female[,2],ylab='heart rate',names=c("male","female"),range=1.5)#boxplot

t.test(male[,2],female[,2], alternative = "two.sided", conf.level = 0.95, var.equal = FALSE) #assume normal and get CI
#all data
plot(data[,1] ~ data[,3],xlab='heartrate',ylab='temperature')
abline(lm(data[,1]~data[,3])) #draw relate line
cor(data[,1], data[,3]) #correlation

#summary(lm(data[,1] ~ data[,3], data))

#separate sex male
plot(male[,1] ~ male[,2],xlab='heartrate',ylab='temperature')
abline(lm(male[,1] ~ male[,2])) #draw relate line
cor(male[,1], male[,2]) #correlation
#separate sex female
plot(female[,1] ~ female[,2],xlab='heartrate',ylab='temperature')
abline(lm(female[,1] ~ female[,2])) #draw relate line
cor(female[,1], female[,2]) #correlation


#2222222222222222222222222
zinterval<-function(data,lembda)
{
  m<-mean(data)
  s<-sd(data)  #standard devition
  L<-m-qnorm(0.975)*s/sqrt(length(data))    #confidence interval for mean
  R<-m+qnorm(0.975)*s/sqrt(length(data))
  if(1/lembda>=L&&1/lembda<=R) return (1);  #judge if in the interval
  return (0);
}
bootinterval<-function(data,lembda)
{
  m<-mean(data)
  boot<-replicate(mean(rexp(rate=1/m,n=length(data))),n=999) #parametric bootstrap with lembda generated by sample mean
  L<-quantile(boot,0.025)
  R<-quantile(boot,0.975)
  if(1/lembda>=L&&1/lembda<=R) return (1);  #judge if in the interval
  return (0);
}
data<-rexp(100,rate=0.01)
mean(replicate(zinterval(data,0.01),n=100))
generate_one<-function(lembda,num)  #compute convarge
{
  data<-rexp(num,rate=lembda)
  dataz<-zinterval(data,lembda) #calculate coverage by useing mean
  datab<-bootinterval(data,lembda) 
  return (c(dataz,datab))
}
coverage<-function(lembda,num)
{
  output<-replicate(generate_one(lembda,num),n=5000)  #do 5000times
  message("lembda: ",lembda," n: ",num)
  o1<-mean(output[1,])  #get mean
  o2<-mean(output[2,])
  print(o1)
  print(o2)
  return (c(o1,o2))
}

#get all output
n<-c(5,10,30,100)
lembda<-c(0.01,0.1,1,10)
combination<-expand.grid(n,lembda)  # get all combination
v = as.vector(unlist(combination))
#combination<-matrix(v,ncol=2,byrow=FALSE)

final<-mapply(coverage,combination[,2],combination[,1])

#draw plot

barplot(final,beside=T,xlab=combination,ylim=c(0,1))

#does it depend on lembda
sub<-final[1:2,1:4]
barplot(sub,beside=T,xlab="lambd=0.01  n:5 10 30 100 left:z right:boot" ,ylim = c(0, 1))
sub<-final[1:2,5:8]
barplot(sub,beside=T,xlab="lambd=0.1  n:5 10 30 100 left:z right:boot" ,ylim = c(0, 1))
sub<-final[1:2,9:12]
barplot(sub,beside=T,xlab="lambd=1  n:5 10 30 100 left:z right:boot" ,ylim = c(0, 1))
sub<-final[1:2,13:16]
barplot(sub,beside=T,xlab="lambd=10  n:5 10 30 100 left:z right:boot" ,ylim = c(0, 1))
plot(y=final[1,1:4],x=c(5,10,30,100),type="o",xlab="lambd=0.01  z:lower boot:higher",ylim = c(0, 1),xlim=c(0,100)) #see line plot
lines(final[2,1:4],x=c(5,10,30,100),type="o")
plot(final[1,5:8],x=c(5,10,30,100),type="o",xlab="lambd=0.1  z:lower boot:higher",ylim = c(0, 1)) #see line plot
lines(final[2,5:8],x=c(5,10,30,100),type="o")
plot(final[1,9:12],x=c(5,10,30,100),type="o",xlab="lambd=1  z:lower boot:higher",ylim = c(0, 1)) #see line plot
lines(final[2,9:12],x=c(5,10,30,100),type="o")
plot(final[1,13:16],x=c(5,10,30,100),type="o",xlab="lambd=10  z:lower boot:higher",ylim = c(0, 1)) #see line plot
lines(final[2,13:16],x=c(5,10,30,100),type="o")
#so it doesn't depend on lembda
#

#test
coverage(0.01,5)
coverage(0.01,100)

data<-rexp(100,rate=0.01)
zinterval(data,0.01)
out<-bootinterval(data,0.01)
sd(data)
mean(data)
rexp(rate=0.01,n=length(data))

#answer
# lembda: 0.01 n: 5
# [1] 0.7034
# [1] 0.8932
# lembda: 0.01 n: 10
# [1] 0.8266
# [1] 0.9278
# lembda: 0.01 n: 30
# [1] 0.8576
# [1] 0.9352
# lembda: 0.01 n: 100
# [1] 0.8928
# [1] 0.95
# lembda: 0.1 n: 5
# [1] 0.7124
# [1] 0.9016
# lembda: 0.1 n: 10
# [1] 0.8188
# [1] 0.9236
# lembda: 0.1 n: 30
# [1] 0.8666
# [1] 0.9334
# lembda: 0.1 n: 100
# [1] 0.8872
# [1] 0.9434
# lembda: 1 n: 5
# [1] 0.7146
# [1] 0.9016
# lembda: 1 n: 10
# [1] 0.8192
# [1] 0.9196
# lembda: 1 n: 30
# [1] 0.8618
# [1] 0.934
# lembda: 1 n: 100
# [1] 0.8892
# [1] 0.9458
# lembda: 10 n: 5
# [1] 0.7116
# [1] 0.893
# lembda: 10 n: 10
# [1] 0.8182
# [1] 0.9192
# lembda: 10 n: 30
# [1] 0.8622
# [1] 0.9346
# lembda: 10 n: 100
# [1] 0.8892
# [1] 0.9462
#++++++++++++++++++++++++++
# lembda: 0.01 n: 5
# [1] 0.7116
# [1] 0.8948
# lembda: 0.01 n: 10
# [1] 0.8212
# [1] 0.9248
# lembda: 0.01 n: 30
# [1] 0.8654
# [1] 0.9354
# lembda: 0.01 n: 100
# [1] 0.8846
# [1] 0.9434
# lembda: 0.1 n: 5
# [1] 0.7028
# [1] 0.8904
# lembda: 0.1 n: 10
# [1] 0.8274
# [1] 0.923
# lembda: 0.1 n: 30
# [1] 0.8672
# [1] 0.934
# lembda: 0.1 n: 100
# [1] 0.8976
# [1] 0.9494
# lembda: 1 n: 5
# [1] 0.723
# [1] 0.8952
# lembda: 1 n: 10
# [1] 0.819
# [1] 0.9228
# lembda: 1 n: 30
# [1] 0.8626
# [1] 0.9354
# lembda: 1 n: 100
# [1] 0.8888
# [1] 0.9426
# lembda: 10 n: 5
# [1] 0.7206
# [1] 0.901
# lembda: 10 n: 10
# [1] 0.832
# [1] 0.928
# lembda: 10 n: 30
# [1] 0.8664
# [1] 0.9326
# lembda: 10 n: 100
# [1] 0.8916
# [1] 0.9412

# [,1]   [,2]   [,3]   [,4]   [,5]   [,6]   [,7]   [,8]   [,9]  [,10]  [,11]  [,12]  [,13]
# [1,] 0.7116 0.8212 0.8654 0.8846 0.7028 0.8274 0.8672 0.8976 0.7230 0.8190 0.8626 0.8888 0.7206
# [2,] 0.8948 0.9248 0.9354 0.9434 0.8904 0.9230 0.9340 0.9494 0.8952 0.9228 0.9354 0.9426 0.9010
# [,14]  [,15]  [,16]
# [1,] 0.832 0.8664 0.8916
# [2,] 0.928 0.9326 0.9412